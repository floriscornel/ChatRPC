import { Schema } from './schema';

/**
 * This is the definition of a method that can be called by the LLM.
 * The input and output are defined by a {@link Schema}.
 * The handler is an async function that takes the input and returns the output.
 *
 * @template Input The input type for this method. This will be generated by the LLM.
 * @template Output The output type for this method. This will be interpreted by the LLM.
 *
 * @example
 * Here's a simple example:
 * ```ts
 * const isEvenMethod: Method<number, boolean> = {
 *   inputDefinition: {
 *     type: 'number',
 *   },
 *   outputDefinition: {
 *     type: 'boolean',
 *   },
 *   handler: (input) => {
 *     return input % 2 === 0;
 *   },
 * };
 * const result = await isEvenMethod.handler(123); // false
 * ```
 * @example
 * Here's a more complex example:
 * ```ts
 * type ReserveIn = { hotelId: number; roomId: number; userEmail: string };
 * type ReserveOut = { reservationId?: number; error?: string };
 * const reserveHotelRoomMethod: Method<ReserveIn, ReserveOut> = {
 *   inputDefinition: {
 *     type: 'object',
 *     properties: {
 *       hotelId: { type: 'number' },
 *       roomId: { type: 'number' },
 *       userEmail: { type: 'string' },
 *     },
 *     required: ['hotelId', 'roomId', 'userEmail'],
 *   },
 *   outputDefinition: {
 *     type: 'object',
 *     properties: {
 *       reservationId: { type: 'number' },
 *       error: { type: 'string' },
 *     },
 *   },
 *   handler: async (input) => {
 *     const { data } = await axios.post('/user', input);
 *     if (data.error) { return { error: data.error }; };
 *     return { reservationId: data.reservationId };
 *   },
 * };
 * ```
 */
export interface Method<Input, Output> {
  /**
   * The async function that handles the method call. It takes an input of type `Input`
   * and returns a value of type `Output` or a Promise that resolves to `Output`.
   */
  handler: (input: Input) => Promise<Output>;
  /**
   * This {@link Schema} defines the input type. It can be a simple type like `number` or `string`,
   * or it can be a complex type like an object or an array. Nested objects and arrays are also supported.
   *
   * The expectation is that this methods input will be generated by a LLM. The LLM will generate the input
   * based on the input definition. Make sure to validate the input before using it. You can use the
   * {@link validate} function to validate the input.
   */
  inputDefinition: Schema<Input>;
  /**
   * This {@link Schema} defines the output type. It can be a simple type like `number` or `string`,
   * or it can be a complex type like an object or an array. Nested objects and arrays are also supported.
   */
  outputDefinition: Schema<Output>;
  /**
   * This description can be used to describe the method. This can be read by the LLM.
   */
  description?: string;
  /**
   * A number of keywords that describe the method. This can be used by the LLM to filter methods.
   */
  keywords?: string[];
}
