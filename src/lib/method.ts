import { Schema } from './schema';

/**
 * This is the definition of a method that can be called by the LLM.
 * The input and output are defined by a {@link Schema}.
 * The handler is an async function that takes the input and returns the output.
 *
 * @template Input The input type for this method. This will be generated by the LLM.
 * @template Output The output type for this method. This will be interpreted by the LLM.
 *
 * @example
 * Here's a simple example:
 * ```ts
 * const isEvenMethod = new Method<number, boolean>(
 *   async (input) => input % 2 === 0,
 *   { type: 'number' },
 *   { type: 'boolean' }
 * );
 * const result = await isEvenMethod.handler(123); // false
 *
 * ```
 * @example
 * Here's a more complex example:
 * ```ts
 * type ReserveIn = { hotelId: number; roomId: number; userEmail: string };
 * type ReserveOut = { reservationId?: number; error?: string };
 * const reserveHotelRoomMethod = new Method<ReserveIn, ReserveOut>(
 *   {
 *   async (input) => {
 *     const { data } = await axios.post('/user', input);
 *     if (data.error) {
 *       return { error: data.error };
 *     }
 *     return { reservationId: data.reservationId };
 *   }
 *     type: 'object',
 *     properties: {
 *       hotelId: { type: 'number' },
 *       roomId: { type: 'number' },
 *       userEmail: { type: 'string' },
 *     },
 *     required: ['hotelId', 'roomId', 'userEmail'],
 *   },
 *   {
 *     type: 'object',
 *     properties: {
 *       reservationId: { type: 'number' },
 *       error: { type: 'string' },
 *     },
 *   },
 * );
 * ```
 */

export class Method<Input, Output> {
  private _handler: (input: Input) => Promise<Output>;
  private _input: Schema<Input>;
  private _output?: Schema<Output>;
  private _description?: string;
  private _keywords?: string[];

  get handler() {
    return this._handler;
  }

  constructor(config: {
    /**
     * The async function that handles the method call. It takes an input of type `Input`
     * and returns a value of type `Output` or a Promise that resolves to `Output`.
     */
    handler: (input: Input) => Promise<Output>;
    /**
     * This {@link Schema} defines the input type. It can be a simple type like `number` or `string`,
     * or it can be a complex type like an object or an array. Nested objects and arrays are also supported.
     *
     * The expectation is that this methods input will be generated by a LLM. The LLM will generate the input
     * based on the input definition. Make sure to validate the input before using it. You can use the
     * {@link validate} function to validate the input.
     */
    input: Schema<Input>;
    /**
     * This {@link Schema} defines the output type. It can be a simple type like `number` or `string`,
     * or it can be a complex type like an object or an array. Nested objects and arrays are also supported.
     */
    output?: Schema<Output>;
    /**
     * This description can be used to describe the method. This can be read by the LLM.
     */
    description?: string;
    /**
     * A number of keywords that describe the method. This can be used by the LLM to filter methods.
     */
    keywords?: string[];
  }) {
    this._handler = config.handler;
    this._input = config.input;
    this._output = config.output;
    this._description = config.description;
    this._keywords = config.keywords;
  }

  describe() {
    // Deep clone the object to prevent accidental mutation.
    return JSON.parse(
      JSON.stringify({
        description: this._description,
        keywords: this._keywords,
        input: this._input,
        output: this._output,
      })
    );
  }

  get input(): Readonly<Schema<Input>> {
    return this._input;
  }

  get output(): Readonly<Schema<Output> | undefined> {
    return this._output;
  }
}
